# -*- coding: utf-8 -*-
# Generates a function call map file for a Go binary.
# Designed for Ghidra headless mode only.

import os
from java.io import File, FileWriter, BufferedWriter

def get_source_location(function):
    """Get source file and line number - simplified version"""
    try:
        symbol = function.getSymbol()
        if symbol is not None:
            source_reference = symbol.getSourceReference()
            if source_reference is not None:
                return source_reference.toString()
        
        comment = function.getComment()
        if comment and ".go:" in comment:
            lines = comment.split("\n")
            for line in lines:
                if ".go:" in line:
                    return line.strip()
        
        return "<autogenerated>:1"
        
    except:
        return "<autogenerated>:1"

def should_filter_function(func_name):
    """Filter out user code, keep runtime and system functions"""
    user_code_prefixes = [
        "github.com/user/go-debug-example",
        "main.main"
    ]
    
    for prefix in user_code_prefixes:
        if func_name.startswith(prefix):
            return True
    
    return False

def extract_go_info():
    """Extract Go version and architecture info from binary"""
    try:
        from ghidra.app.util.bin.format.golang import GoVer
        
        goVersion = GoVer.fromProgramProperties(currentProgram)
        go_version = goVersion.toString()
        print "Detected Go version: " + go_version
        
        processor = currentProgram.getLanguage().getProcessor()
        processor_str = processor.toString()
        print "Detected processor: " + processor_str
        
        if "x86" in processor_str.lower():
            try:
                lang_desc = currentProgram.getLanguage().toString().lower()
                if "64" in lang_desc:
                    arch = "amd64"
                else:
                    arch = "386"
            except:
                arch = "amd64"
        elif "arm" in processor_str.lower():
            lang_desc = currentProgram.getLanguage().toString().lower()
            if "64" in lang_desc:
                arch = "arm64"
            else:
                arch = "arm"
        else:
            arch = "amd64"
        
        os_name = "unknown"
        
        try:
            exec_path = currentProgram.getExecutablePath()
            if exec_path:
                exec_path_lower = exec_path.lower()
                if ".exe" in exec_path_lower:
                    os_name = "windows"
                elif exec_path_lower.startswith("/usr/") or exec_path_lower.startswith("/bin/"):
                    os_name = "linux"
                elif "/applications/" in exec_path_lower or ".app/" in exec_path_lower:
                    os_name = "darwin"
        except:
            pass
        
        if os_name == "unknown":
            try:
                lang_desc = currentProgram.getLanguage().toString().lower()
                if "windows" in lang_desc:
                    os_name = "windows"
                elif "linux" in lang_desc:
                    os_name = "linux"
                elif "darwin" in lang_desc or "macos" in lang_desc:
                    os_name = "darwin"
            except:
                pass
        
        if os_name == "unknown":
            os_name = "windows"
            print "Using default OS: windows"
        
        go_arch = os_name + "_" + arch
        go_version_with_prefix = "go" + go_version
        
        print "Extracted Go info - Version: " + go_version + ", Arch: " + go_arch
        return go_version_with_prefix, go_arch
        
    except Exception, e:
        print "Warning: Could not extract Go info: " + str(e)
        print "Using default values"
        return "go1.23.4", "windows_amd64"

def run():
    """Main function - designed for headless mode"""
    
    args = getScriptArgs()
    if len(args) < 1:
        print "Usage: script.py [output_dir]"
        output_dir = os.getcwd()
    else:
        output_dir = args[0]
    
    go_version, go_arch = extract_go_info()
    
    print "Go Call Map Generator (Headless)"
    print "================================="
    print "Go Version: " + go_version
    print "Architecture: " + go_arch
    print "Output Directory: " + output_dir
    print ""
    
    if currentProgram is None:
        print "ERROR: No current program found!"
        return
    
    print "Program: " + currentProgram.getName()
    print ""
    
    if not os.path.exists(output_dir):
        print "Creating output directory: " + output_dir
        try:
            os.makedirs(output_dir)
        except Exception, e:
            print "Failed to create output directory: " + str(e)
            return
    
    output_filename = go_arch + "_" + go_version + ".txt"
    output_path = os.path.join(output_dir, output_filename)
    print "Output file: " + output_path
    print ""
    
    func_manager = currentProgram.getFunctionManager()
    total_funcs = func_manager.getFunctionCount()
    print "Total functions found: " + str(total_funcs)
    
    try:
        output_file = File(output_path)
        parent_dir = output_file.getParentFile()
        if parent_dir is not None and not parent_dir.exists():
            parent_dir.mkdirs()
        
        writer = BufferedWriter(FileWriter(output_path))
        
        print "Analyzing functions..."
        print ""
        
        func_count = 0
        call_count = 0
        
        functions = func_manager.getFunctions(True)
        while functions.hasNext():
            func = functions.next()
            
            if func.isThunk():
                continue

            entry_point = func.getEntryPoint()
            caller_address = entry_point.toString().replace("ram:", "")
            caller_name = func.getName(True)
            
            if should_filter_function(caller_name):
                continue
                
            caller_source_loc = get_source_location(func)

            called_functions = func.getCalledFunctions(getMonitor())
            callee_names = []
            
            for called_func in called_functions:
                callee_name = called_func.getName(True)
                if not should_filter_function(callee_name):
                    callee_names.append(callee_name)

            if not callee_names:
                continue
            
            line_parts = [caller_address, caller_name, caller_source_loc] + callee_names
            output_line = "|".join(line_parts)
            writer.write(output_line + "\n")
            
            func_count += 1
            call_count += len(callee_names)
            
            if func_count % 100 == 0:
                print "Processed " + str(func_count) + " functions..."
        
        writer.close()
        
        print ""
        print "Analysis completed!"
        print "=================="
        print "Functions with calls: " + str(func_count)
        print "Total call relationships: " + str(call_count)
        print "Output file: " + output_path
        print ""
        
        if os.path.exists(output_path):
            file_size = os.path.getsize(output_path)
            print "File size: " + str(file_size) + " bytes"
            print "SUCCESS: Call map file generated successfully!"
        else:
            print "ERROR: Output file was not created!"
            
    except Exception, e:
        print "ERROR: " + str(e)
        import traceback
        traceback.print_exc()

run()